import gzip
import csv
import math
import struct
import random
from pathlib import Path
from PIL import Image
import numpy as np
# import matplotlib.pyplot as plt

def binsearch(xs, x, lo = 0, hi = None):
	if hi is None:
		hi = len(xs)

	clo, chi = (lo, hi)
	while clo < chi:
		center = (clo + chi) // 2
		centerValue = xs[center]
		if centerValue > x:
			chi = center
		elif centerValue < x:
			clo = center + 1
		else:
			return (True, center)
	
	center = (clo + chi) // 2
	return (False, center)

def lerp(t, a, b):
	return a + t * (b - a)
def invlerp(v, a, b):
	return (v - a) / (b - a)

class FunctionLut(object):
	def __init__(self):
		self.inputs = []
		self.outputs = []
		self.domain_min = math.inf
		self.domain_max = -math.inf

	def insert(self, input, output):
		found, index = binsearch(self.inputs, input)
		self.domain_min = min(self.domain_min, input)
		self.domain_max = max(self.domain_max, input)
		if not found:
			self.inputs.insert(index, input)
			self.outputs.insert(index, output)
		else:
			self.inputs[index] = input
			self.outputs[index] = output

	def apply(self, input):
		# if input - self.domain_max < 1e-9:
		# 	input = self.domain_max
		if input < self.domain_min or input > self.domain_max:
			print(f"input {input} outside domain [{self.domain_min}, {self.domain_max}]")
			return None
		found, index = binsearch(self.inputs, input)
		if found:
			return self.outputs[index]
		else:
			ilo = self.inputs[index - 1]
			ihi = self.inputs[index]
			olo = self.outputs[index - 1]
			ohi = self.outputs[index]
			return lerp(invlerp(input, ilo, ihi), olo, ohi)

# physical constants in base SI units
h = 6.62607015e-34 # planck's constant
c = 2.99792458e8 # speed of light
k = 1.380649e-23 # boltzmann constant

# T in K, l in nm
# output is W sr^-1 m^-2 Hz^-1 (spectral radiance)
def blackbody_spectral_radiance(T, l):
	c1 = 2 * math.pi * h * c * c
	c2 = h * c / k
	return c1 * (l ** -5) / (math.exp(c2 / (l * T)) - 1)

# T in K
# output is W sr^-1 m^-2 (radiance)
def blackbody_radiance(T):
	c1 = (2 * (math.pi ** 5) * (k ** 4)) / (15 * (h ** 3) * (c ** 2))
	return c1 * (T ** 4)

def linspace(start, end, steps):
	if steps == 0:
		return
	if steps == 1:
		yield start
		return
	step = (end - start) / (steps - 1)
	cur = start
	for i in range(0, steps):
		yield cur
		cur += step

def logspace(base, start, end, steps):
	for i in linspace(0, 1, steps):
		i = (base ** i - 1) / (base - 1)
		yield lerp(i, start, end)

# not great for functions with large derivatives, or functions with discontinuities
# but it shouldn't matter much in our case
def integrate_trapezoid(lo, hi, steps, func):
	dx = (hi - lo) / steps
	sum = 0.0
	prev = func(lo)
	for i in range(1, steps + 1):
		x = lerp(i / steps, lo, hi)
		cur = func(x)
		sum += dx * (prev + cur) / 2
		prev = cur
	return sum

class Mat3(object):
	def __init__(self, m00, m01, m02, m10, m11, m12, m20, m21, m22):
		self.m00 = m00
		self.m01 = m01
		self.m02 = m02
		self.m10 = m10
		self.m11 = m11
		self.m12 = m12
		self.m20 = m20
		self.m21 = m21
		self.m22 = m22

	def mul(self, x, y, z):
		xn = self.m00 * x + self.m01 * y + self.m02 * z
		yn = self.m10 * x + self.m11 * y + self.m12 * z
		zn = self.m20 * x + self.m21 * y + self.m22 * z
		return (xn, yn, zn)

def gamma_correct_sRGB(c_linear):
	if c_linear <= 0.0031308:
		return 12.92  * c_linear
	else:
		return 1.055 * (c_linear ** (1 / 2.4)) - 0.055

CIEXYZ_TO_SRGB = Mat3(
	+3.2404542, -1.5371385, -0.4985314,
	-0.9692660, +1.8760108, +0.0415560,
 	+0.0556434, -0.2040259, +1.0572252)

def xy_to_sRGB(x, y, Y=1):
	X = (Y / y) * x
	Z = (Y / y) * (1 - x - y)
	r, g, b = CIEXYZ_TO_SRGB.mul(X, Y, Z)
	rgbmax = max(r, g, b)
	r = np.clip(Y * r / rgbmax, 0, 1)
	g = np.clip(Y * g / rgbmax, 0, 1)
	b = np.clip(Y * b / rgbmax, 0, 1)
	r = gamma_correct_sRGB(r)
	g = gamma_correct_sRGB(g)
	b = gamma_correct_sRGB(b)
	return (r, g, b)

INPUT_PATH = Path('scripts/lin2012xyz2e_fine_7sf.csv')
OUTPUT_PATH = Path('src/main/resources/black_body_lut.bin')

lut_cm_X = FunctionLut()
lut_cm_Y = FunctionLut()
lut_cm_Z = FunctionLut()

with INPUT_PATH.open('rt') as f:
	# skip column description
	columns = [x.strip() for x in next(f).split(',')]

	row = {}
	for row_index, raw_row in enumerate(f):
		raw_row = [x.strip() for x in raw_row.split(',')]
		for i in range(0, len(columns)):
			cell = raw_row[i]
			row[columns[i]] = cell if cell != '' else None

		# nm -> m
		lut_cm_X.insert(1e-9 * float(row['freq']), float(row['X']))
		lut_cm_Y.insert(1e-9 * float(row['freq']), float(row['Y']))
		lut_cm_Z.insert(1e-9 * float(row['freq']), float(row['Z']))

class Column(object):
	def __init__(self, name, formatter):
		self.name = name
		self.formatter = formatter

# the number of entries generated by this program
TEMPERATURE_STEPS = 16384
# the temperature of the minimum entry
TEMPERATURE_MIN = 1000
# the temperature of the maximum entry
TEMPERATURE_MAX = 40000
# the number of spectral radiance integration steps for each wavelength
WAVELENGTH_STEPS = 128
# the lower bound for spectral radiance integration
WAVELENGTH_MIN = 390.0
# the upper bound for spectral radiance integration
WAVELENGTH_MAX = 830.0

COLUMN_INDEX = Column('index', (lambda val: f"{val:.0f}"))
# temperature (K)
COLUMN_TEMPERATURE = Column('temperature', lambda val: f"{val:.0f}")
# radiance of a blackbody radiator at a certain temperature in the visible wavelengths (W sr^-1 m^-2)
COLUMN_VISIBLE_RADIANCE = Column('visible_radiance', lambda val: f"{val:.4e}")
# radiance of a blackbody radiator overall (W sr^-1 m^-2)
COLUMN_BOLOMETRIC_RADIANCE = Column('bolometric_radiance', lambda val: f"{val:.4e}")
# ratio between the visible radiance and the bolometric radiance
COLUMN_BOLOMETRIC_RATIO = Column('bolometric_ratio', lambda val: f"{val:.4e}")
# color of the blackbody radiator (CIE 1931 XYZ)
# radiance of the blackbody curve with color matching filters applied, integrated over the visible spectrum
COLUMN_X = Column('X', lambda val: f"{val:.4e}")
COLUMN_Y = Column('Y', lambda val: f"{val:.4e}")
COLUMN_Z = Column('Z', lambda val: f"{val:.4e}")
# "efficiency" of each color matching filter
COLUMN_EFFICENCY_X = Column('eff_X', lambda val: f"{val:.4f}")
COLUMN_EFFICENCY_Y = Column('eff_Y', lambda val: f"{val:.4f}")
COLUMN_EFFICENCY_Z = Column('eff_Z', lambda val: f"{val:.4f}")
# chromaticity coordinates of the blackbody radiator
COLUMN_x = Column('x', lambda val: f"{val:.4f}")
COLUMN_y = Column('y', lambda val: f"{val:.4f}")
# color of the blackbody radiator (linear sRGB)
# essentially just a linear transformation of XYZ coordinates to sRGB.these values might be negative, or might be greater than 1.
COLUMN_R = Column('r', lambda val: f"{val:.4f}")
COLUMN_G = Column('g', lambda val: f"{val:.4f}")
COLUMN_B = Column('b', lambda val: f"{val:.4f}")
# color of the blackbody radiator (sRGB)
COLUMN_R_CLIPPED = Column('r_clipped', lambda val: f"{255 * val:.0f}")
COLUMN_G_CLIPPED = Column('g_clipped', lambda val: f"{255 * val:.0f}")
COLUMN_B_CLIPPED = Column('b_clipped', lambda val: f"{255 * val:.0f}")

class DataGenerator(object):
	def __init__(self):
		pass

	def start():
		pass

	def emit(self, row):
		pass

	def finish():
		pass

class CompositeGenerator(DataGenerator):
	def __init__(self, generators):
		super().__init__()
		self.generators = generators

	def start(self):
		for gen in self.generators:
			gen.start()

	def emit(self, row):
		for gen in self.generators:
			gen.emit(row)

	def finish(self):
		for gen in self.generators:
			gen.finish()

class DummyGenerator(DataGenerator):
	def __init__(self):
		super().__init__()

	def emit(self, row):
		pass

def integrate_spectral_radiance(temperature, filter):
	return integrate_trapezoid(1e-9 * WAVELENGTH_MIN, 1e-9 * WAVELENGTH_MAX, WAVELENGTH_STEPS, lambda l: filter(l) * blackbody_spectral_radiance(temperature, l))

# max_radiance_Y = integrate_spectral_radiance(TEMPERATURE_MAX, lambda l: lut_cm_Y.apply(l))

class ImageGenerator(DataGenerator):
	def __init__(self, width, height):
		super().__init__()
		self.image_data = np.zeros((height, width, 3), dtype=np.uint8)
		self.height = height

	def emit(self, row):
		i = row[COLUMN_INDEX]
		r, g, b = xy_to_sRGB(
			row[COLUMN_x],
			row[COLUMN_y],
			1,
			# row[COLUMN_Y] / max_radiance_Y,
		)
		rgb = (255 * r, 255 * g, 255 * b)
		for j in range(0, self.height):
			self.image_data[j, i] = rgb

class CsvGenerator(DataGenerator):
	def __init__(self, output, columns):
		super().__init__()
		self.output = output
		self.columns = columns

	def start(generator):
		self.output.write(','.join([col.name for col in self.columns]))
		self.output.write('\n')

	def emit(self, row):
		self.output.write(','.join([(col in row and col.formatter(row[col])) or '' for col in self.columns]))
		self.output.write('\n')

# columns: i32
# column_names: [length: i32, string_data: u8[length]] # (utf-8)
# rows: i32
# temperature_bounds: [min: f32, max: f32]
# data: f32[columns][rows]
class BinaryGenerator(DataGenerator):
	def __init__(self, output, columns):
		super().__init__()
		self.output = output
		self.columns = columns
		self.row_count_position = None
		self.row_count = 0

	def finish(self):
		self.output.seek(self.row_count_position)
		self.output.write(struct.pack('>i', self.row_count))

	def start(self):
		self.output.write(struct.pack('>ff', TEMPERATURE_MIN, TEMPERATURE_MAX))
		self.output.write(struct.pack('>i', len(self.columns)))
		for col in self.columns:
			self.output.write(struct.pack('>i', len(col.name)))
			self.output.write(col.name.encode())
		# placeholder, will be filled in later
		self.row_count_position = self.output.tell()
		self.output.write(struct.pack('>i', 0))
	
	def emit(self, row):
		self.row_count += 1
		for col in self.columns:
			self.output.write(struct.pack('>f', row[col]))

def create_temperature_table(generator):
	generator.start()

	row = {}
	for i, temperature in enumerate(linspace(TEMPERATURE_MIN, TEMPERATURE_MAX, TEMPERATURE_STEPS)):
		row[COLUMN_INDEX] = i
		row[COLUMN_TEMPERATURE] = temperature

		radiance_total = integrate_spectral_radiance(temperature, lambda l: 1)
		radiance_X = integrate_spectral_radiance(temperature, lambda l: lut_cm_X.apply(l))
		radiance_Y = integrate_spectral_radiance(temperature, lambda l: lut_cm_Y.apply(l))
		radiance_Z = integrate_spectral_radiance(temperature, lambda l: lut_cm_Z.apply(l))
		radiance_bolometric = blackbody_radiance(temperature)

		row[COLUMN_VISIBLE_RADIANCE] = radiance_total
		row[COLUMN_BOLOMETRIC_RADIANCE] = radiance_bolometric
		row[COLUMN_BOLOMETRIC_RATIO] = radiance_total / radiance_bolometric

		row[COLUMN_X] = radiance_X
		row[COLUMN_Y] = radiance_Y
		row[COLUMN_Z] = radiance_Z

		row[COLUMN_EFFICENCY_X] = radiance_X / radiance_total
		row[COLUMN_EFFICENCY_Y] = radiance_Y / radiance_total
		row[COLUMN_EFFICENCY_Z] = radiance_Z / radiance_total

		radiance_total = radiance_X + radiance_Y + radiance_Z
		radiance_x = radiance_X / radiance_total
		radiance_y = radiance_Y / radiance_total

		row[COLUMN_x] = radiance_x
		row[COLUMN_y] = radiance_y

		radiance_r, radiance_g, radiance_b = CIEXYZ_TO_SRGB.mul(radiance_X, radiance_Y, radiance_Z)
		row[COLUMN_R] = radiance_r
		row[COLUMN_G] = radiance_g
		row[COLUMN_B] = radiance_b

		r, g, b = xy_to_sRGB(radiance_x, radiance_y)
		row[COLUMN_R_CLIPPED] = r
		row[COLUMN_G_CLIPPED] = g
		row[COLUMN_B_CLIPPED] = b

		generator.emit(row)
	generator.finish()

DEFAULT_COLUMNS = [COLUMN_TEMPERATURE, COLUMN_BOLOMETRIC_RATIO, COLUMN_EFFICENCY_Y, COLUMN_x, COLUMN_y, COLUMN_Y]
# with open('blackbody.csv', 'w') as f:
# 	create_temperature_table(CsvGenerator(f, DEFAULT_COLUMNS))
with OUTPUT_PATH.open('wb') as f:
	create_temperature_table(BinaryGenerator(f, DEFAULT_COLUMNS))

# generator = ImageGenerator(TEMPERATURE_STEPS, 256)
# create_temperature_table(generator)
# image = Image.fromarray(generator.image_data)
# image.save('spectrum.png')
